package byog.Core;
import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import byog.TileEngine.TETile;
import byog.TileEngine.Tileset;
//import javafx.geometry.Pos;

import java.util.ArrayList;

public class WorldGenerator implements Serializable {

    protected TETile [][] myWorld;
    private  Random myRand;
    private  static final int UP = 0;
    private  static final int DOWN = 1;
    private  static final int LEFT = 2;
    private  static final int RIGHT = 3;
    private int currentRand;
    private int power;
    private Constructor construct;
    private Position charac;
    private static Position [] pos;
    private static int hallDirection;
    private String name;
    //values to keep track of the number of doors/portals
    private Map<Integer, Position> myDoors = new HashMap<>();


    public WorldGenerator(TETile [][] world, Random rand) {
        myWorld = world;
        myRand = rand;
        currentRand = getRandomInt();
        pos = new Position[2];
        hallDirection = createDirec();
        this.construct = new Constructor(myWorld);
    }

    //default generator (never used) just for compilation
    public WorldGenerator() {

    }

    /*
      World is generated by first placing nothing tiles
      Rooms are generated 90 times
      Places doors/hallways on open hallways
     */
    public TETile[][] generateWorld() {
        for (int x = 0; x < 80; x += 1) {
            for (int y = 0; y < 40; y += 1) {
                myWorld[x][y] = Tileset.NOTHING;
            }
        }
        for (int x = 0; x < 90; x++) {
            generateRoom();
        }
        Room.setArray(new ArrayList<Room>());
        closeAllEmpty();
        return myWorld;
    }

    /*
      Makes a hall perpendicular to the current one
     */
    private  void makeHallToHall(int length) {
        int temp =  generateInt();
        Boolean even = false;
        if (temp % 2 == 0) {
            even = true;
        }
        int perp = perpendicular(hallDirection, even);
        Position startPos = startPositionOfHall(perp);
        int xPos = startPos.getX();
        int yPos = startPos.getY();
        if (perp == UP || perp == DOWN) {
            yPos = startPos.getY();
            if (hallDirection == RIGHT) {
                xPos = startPos.getX() - 1;
            } else {
                xPos = startPos.getX() - 1;
            }
        } else {
            xPos = startPos.getX();
            if (hallDirection == UP) {
                yPos = startPos.getY() - 1;
            } else {
                yPos = startPos.getY() + 1;
            }
        }
        hallDirection = perp;
        pos = construct.makeHall(length, perp, new Position(xPos, yPos), true);
    }

    /*
      Determines the location to build the perpendicular hall
      Retunrs a Position
     */
    private Position startPositionOfHall(int perp) {
        int temp =  generateInt();
        Position startPos = null;
        if (perp == UP || perp == RIGHT) {
            startPos = pos[0];
        } else {
            startPos = pos[1];
        }
        return startPos;
    }

    /*
    returns which direction to build an L shaped hall
     */
    private int perpendicular(int hallDirec, boolean even) {
        if (hallDirec == UP || hallDirec == DOWN) { // up and even which means right
            if (even) {
                return RIGHT;
            } else {
                return LEFT;
            }
        } else {
            if (even) { // 1 and 2 1 is down go to right  2  left  up 0
                return UP;
            } else {
                return DOWN;
            }
        }
    }

    /*
      Makes a hall from a random side of the room
     */
    private void makeHallFromRoom(int length, Room room) {
        int xPos;
        int yPos;
        if (hallDirection == UP || hallDirection == DOWN) {
            xPos = room.getTopLeftEdge().getX() + (room.getWidth() / 2);
            if (hallDirection == UP) {
                yPos = room.getTopLeftEdge().getY();
            } else {
                yPos = room.getBottomLeftEdge().getY();
            }
        } else {
            yPos = room.getTopLeftEdge().getY() - (room.getHeight() / 2);
            if (hallDirection == RIGHT) {
                xPos = room.getTopRightEdge().getX();
            } else {
                xPos = room.getTopLeftEdge().getX();
            }
        }
        pos = construct.makeHall(length, hallDirection, new Position(xPos, yPos), false);
    }

    /*
    creates a room and hall connected to it at a random side
     If the hall is made down or to the left add another hall to
     make an L shaped hall.
     */
    private Room generateRoom() {
        //forces game to build a hall perpendicular if currenthall is near the edge of frame
        if (pos[0] != null) {
            boolean top = ((pos[0].getY() + 4) >= Game.HEIGHT);
            boolean bottom = ((pos[0].getY() <= 4));
            if (top || bottom) {
                int perp = perpendicular(hallDirection, generateInt() % 2 == 0);
                int length = generateHallLength();
                Position startPos = startPositionOfHall(perp);
                if (startPos.getX() <= 5 && perp == 2) {
                    perp = 3;
                } else if (startPos.getX() >= Game.HEIGHT - 5 && perp == 3) {
                    perp = 2;
                }
                pos = construct.makeHall(length, perp,
                        new Position(startPos.getX(), startPos.getY()), true);
                hallDirection = perp;
            }
        }
        Room room = makeRoom();
        hallDirection = createDirec();
        int length = generateHallLength();
        if (room != null) {
            makeHallFromRoom(length, room);
        }
        //creates an L shaped hall if the hall built was down or left
        if (hallDirection == 1 || hallDirection == 2) {
            makeHallToHall(generateHallLength());
        }
        return room;
    }

    /*
      generates a random number from 0 - 10
     */
    private int generateInt() {
        int val = currentRand % 10;
        if (val == 0) {
            val = 10;
        }
        currentRand = currentRand / 10;
        if (currentRand == 0) {
            currentRand = getRandomInt();
        }
        return val;
    }
    /*
    Creates a room by establishing room properties: Dimesnsions and Length
    Starting position to build any room will always be bottom left corner
     */
    private Room makeRoom() {
        int [] dimensions = createRoomDimension(generateInt());
        int width = dimensions[0];
        int height = dimensions[1];
        Position startPos;
        if (pos[0] == null) {
            startPos = createStartingPos(generateInt(), width, height);
        } else {
            startPos = pos[0];
        }
        Room room = null;
        if (!Room.isOverlap(startPos)) {
            room = new Room(myWorld, construct, width, height, startPos, createDirec());
            room.makeRoom();

            connectHallToRoom();
            Room.getArray().add(room);
        }
        return room;
    }

    /*
    when rooms are built the hall it connects to gets blocked off
    Method will make sure that this doesnt happen by placing a floor tile where
    hall is blocked off by room.
    MODIFIED
     */
    private void connectHallToRoom() {
        if (pos[0] == null) {
            return;
        }
        if (pos[0].getY() == pos[1].getY()) {
            myWorld[pos[0].getX() + 1][pos[0].getY()] = Tileset.FLOOR;
        } else {
            myWorld[pos[0].getX()][pos[0].getY() + 1] = Tileset.FLOOR;
        }
    }

    /* generates a random position to build hall or room */
    private Position createStartingPos(int rand, int width, int height) {
        currentRand = getRandomInt();
        int xPos = numCutter(currentRand);
        currentRand = currentRand / 100;
        while (xPos >= 30) {
            xPos = xPos % 10;
        }
        int yPos = numCutter(currentRand);
        while (yPos >= 30 || yPos <= 5) {
            if (yPos <= 5) {
                currentRand = getRandomInt();
                yPos = numCutter(currentRand);
                currentRand = currentRand / 100;
            } else {
                yPos = yPos % 10;
            }
        }
        return new Position(xPos, yPos);
    }

    /* Returns a random positive number using Random obj */
    private int getRandomInt() {
        return Math.abs(myRand.nextInt());
    }

    /*
      creates a room by using the last digit of the seed and passing
      into numDimension to get a reasonable width or height
     */
    private int[] createRoomDimension(int rand) {
        int width = numDimension(rand);
        int height = numDimension(generateInt());
        int [] dimensions = new int[]{width, height};
        return dimensions;
    }


    /* generates a direction to build an object */
    private int createDirec() {
        return generateInt() % 4;
    }


    /* numDimension randomly creates the height or width for room dimension */
    private int numDimension(int num) {
        if (num == 0) {
            return 6;
        } else if (num == 1) {
            return 5;
        } else if (num > 7) {
            return (num - 4);
        } else {
            return num;
        }
    }


    /* cuts the number's last 2 digits and returns it */
    private int numCutter(int num) {
        return num % 100;
    }

    /* generates the hall length using generateInt */
    private int generateHallLength() {
        int length = generateInt();
        while (length < 4) {
            length = generateInt();
        }
        return length;
    }

    /* places doors/walls on open halls */
    public void closeAllEmpty() {
        int key = 0;
        for (int i = 0; i < myWorld.length; i++) {
            for (int x = 0; x < myWorld[0].length; x++) {
                boolean bool = (((x - 1) >= 0) && myWorld[i][x - 1] == Tileset.NOTHING); //below
                boolean bool1 = (((i - 1) >= 0) && myWorld[i - 1][x] == Tileset.NOTHING); //left
                boolean bool2 = (((i + 1) <= 79) && myWorld[i + 1][x] == Tileset.NOTHING);
                boolean bool3 = (((x + 1) <= 39) && myWorld[i][x + 1] == Tileset.NOTHING);
                if (myWorld[i][x] == Tileset.FLOOR && (bool || bool1 || bool2 || bool3)) {
                    myWorld[i][x] = placeDoor(i, x);
                    myDoors.put(key, new Position(i, x));
                    key++;
                }
            }
        }
        if (myDoors.size() == 1) {
            myWorld[myDoors.get(0).getX()][myDoors.get(0).getY()]  = Tileset.UNLOCKED_DOOR;
        }
    }

    /*
    replaces a tile surrounded with 3 or more walls with wwall
    else replaces with door
     */
    private TETile placeDoor(int i, int x) {
        Position curr = new Position(i, x);
        Position up = new Position(i, x + 1);
        Position down = new Position(i, x - 1);
        Position right = new Position(i + 1, x);
        Position left = new Position(i - 1, x);
        boolean bool1 = !Constructor.isPositionOutOfBounds(up).equals(up)
                || myWorld[up.getX()][up.getY()].equals(Tileset.WALL);
        boolean bool2 = !Constructor.isPositionOutOfBounds(down).equals(down)
                || myWorld[down.getX()][down.getY()].equals(Tileset.WALL);
        boolean bool3 = !Constructor.isPositionOutOfBounds(right).equals(right)
                || myWorld[right.getX()][right.getY()].equals(Tileset.WALL);
        boolean bool4 = !Constructor.isPositionOutOfBounds(left).equals(left)
                || myWorld[left.getX()][left.getY()].equals(Tileset.WALL);
        int trues = 0;
        if (bool1) {
            trues++;
        }
        if (bool2) {
            trues++;
        }
        if (bool3) {
            trues++;
        }
        if (bool4) {
            trues++;
        }
        if (trues >= 3) {
            return Tileset.WALL;
        } else {
            return Tileset.LOCKED_DOOR;
        }
    }

    /* returns the doors map */
    public Map<Integer, Position> getMyDoors() {
        return myDoors;
    }

    /* returns the state of the world */
    public TETile[][] getMyWorld() {
        return myWorld;
    }

    /* changes the charactersposition */
    public void resetCharacPos(Position newPos) {
        charac = newPos;
    }

    /* returns the characters positions */
    public Position getCharacPos() {
        return charac;
    }

    /* replaces the given coordinates of the world with the given tile */
    public void setMyWorld(int x, int y, TETile tile) {
        getMyWorld()[x][y] = tile;
    }
    /* returns the random object */
    public Random getRand() {
        return myRand;
    }

    /* set method for power variable */
    public void setPower(int power) {
        this.power = power;
    }

    /* get method for power variable */
    public int getPower() {
        return power;
    }

    /* set method to set name variable */
    public void setName(String str) {
        this.name = str;
    }

//    public void setDoors(Map<Integer, Position> myDoors) {
//        this.my
//    }

    /* get method to get name variable */
    public String getName() {
        return name;
    }
}
